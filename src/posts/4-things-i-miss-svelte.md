---
title: 4 things I miss from Svelte after working in React
date: '2022-10-09'
tags:
  - svelte
  - react
socialImage: 'https://geoffrich.net/images/social/4-things-i-miss-svelte.png'
syndication:
  - https://twitter.com/geoffrich_/status/1579478166384816131
  - https://www.reddit.com/r/sveltejs/comments/y0g1p3/4_things_i_miss_from_svelte_after_working_in/
---

I got a new job in August, and I'm really enjoying the new problem space and all the great people I work with! However, like most companies, they write their frontend in React. This took some getting used to after writing Svelte for so long. Here are four things from Svelte that I deeply miss when writing React code.

(Psst - this is not a React hate post. Different frameworks solve different problems! At the end of the day users don't care about the syntax of the frameworks we use; they care about the end experience.)

## Scoped styles

Svelte just makes component styling so easy. You don't have to make a decision about what method to use (styled components? CSS modules? emotion? all global CSS?) and can just write them directly in the component file. Those styles are also [scoped to the component](https://svelte.dev/docs#component-format-style) so you know what might break when you change it.

```svelte
<button>You can style me directly</button>

<style>
  /* I only apply to buttons in this component */
  button {
    color: red;
  }
</style>
```

Sure, there can be some friction (usually when you want to style something _not_ in the component), but for the vast majority of use cases it's all you need.

Since React doesn't have a blessed styling solution, you need to choose one, and that leads to inconsistency in the codebase as different developers bring their own approach to styles.

## Component prop shorthand

This is a small one, but I really miss being able to write this...

```svelte
<Button {disabled}>
```

...instead of this...

```jsx
<Button disabled={disabled}>
```

It's the little things.

## Actions

I love [Svelte actions](https://svelte.dev/tutorial/actions), since they make it easy to tie some behavior to an individual HTML element's lifecycle. I ran into a problem at work that would've been a _perfect_ fit for one (we were adding and removing an iframe and needed to add/remove event listeners and do some setup), but since this wasn't Svelte, it required extra effort.

There's likely a more idiomatic React way of accomplishing this (maybe [a custom hook](https://dev.to/isaachagoel/react-gets-svelte-flavoured-drag-and-drop-or-svelte-actions-via-react-hooks-2pe)), and I ended up going with a combination of `useEffect` and `useRef`. But a Svelte action would have been _so convenient_.

## Automatic reactive dependencies

`useEffect` is a powerful tool, but one annoying thing is that you have to manually list each variable you depend on after the effect.

```js
useEffect(() => {
  doAThingWith(var1, var2, var3);
}, [var1, var2, var3]); // why do I have to write this?
```

Not adding all the dependencies (or adding too many) can lead to subtle bugs where the component doesn't behave as expected. The [React docs](https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect) say that the dependency list may be generated by a compiler in the future, but for now you need to play spot-the-difference and keep it up-to-date manually.

In Svelte, you don't have to do this. Reactive statements will [automatically detect](https://svelte.dev/docs#component-format-script-3-$-marks-a-statement-as-reactive) which variables they depend on and re-run when they change. And because Svelte components don't "re-render" like React components do (the component script tag only runs once), stale closures aren't a concern.

```js
// I will automatically re-run when any of these variables change
$: doAThingWith(var1, var2, var3);
```

## Wrapping up

There are some things I appreciate about React - the ecosystem is very mature, and it's nice how composable hooks are. But I won't be switching from Svelte on anything where I have a choice.
